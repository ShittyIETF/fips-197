
// AES counts (Fig. 4)
template <int N> struct CipherEnum;
template <> struct CipherEnum<128> {
  enum {
    key_length = 4,
    block_size = 4,
    num_rounds = 10,
  };
};
template <> struct CipherEnum<192> {
  enum {
    key_length = 6,
    block_size = 4,
    num_rounds = 12,
  };
};
template <> struct CipherEnum<256> {
  enum {
    key_length = 8,
    block_size = 4,
    num_rounds = 14,
  };
};


template <int N>
struct Cipher {
  enum {
    key_length = CipherEnum<N>::key_length,
    block_size = CipherEnum<N>::block_size,
    num_rounds = CipherEnum<N>::num_rounds,
    expansion_length = block_size * (num_rounds + 1)
  };

  // TODO don't use inheritance for types like array<>
  struct CipherKey :          public array<Vec4, Cipher<N>::key_length> {};
  struct CipherKeyExpansion : public array<Vec4, Cipher<N>::expansion_length> {};

  static CipherKeyExpansion expandKey(const CipherKey &key) {
    static Byte round_constant[11] = {
      0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
    };

    CipherKeyExpansion r;
    Vec4 temp;

    for (int i = 0; i < key_length; ++i) {
      r[i] = key[i];
    }

    for (int i = key_length; i < expansion_length; ++i) {
      temp = r[i-1];
      if (i % key_length == 0) {
        // TODO make this better
        Polynomial p1;
        p1.base() = subWord(rotWord(temp));
        // TODO store round_constant as Vec4?
        Polynomial p2(round_constant[i / key_length], 0 , 0, 0);
        temp = add(p1, p2).base();
      } else if (key_length > 6 && i % key_length == 4) {
        temp = subWord(temp);
      }
      // TODO make this better
      Polynomial p1, p2;
      p1.base() = r[i - key_length];
      p2.base() = temp;
      r[i] = add(p1, p2).base();
    }

    return r;
  }

  static Block encrypt(const CipherKeyExpansion &key, const Block &input) {
    Block state = input;
    state.addRoundKey(&key[0]);

    for (int round = 1; round < num_rounds; ++round) {
      // TODO: make these object oriented
      state = subBytes(state);
      state = shiftRows(state);
      state = mixColumns(state);
      state.addRoundKey(&key[4 * round]);
    }

    // No mixColumns at the final round
    state = subBytes(state);
    state = shiftRows(state);
    state.addRoundKey(&key[4 * num_rounds]);

    return state;
  }

  static Block decrypt(const CipherKeyExpansion &key, const Block &input);


};




